/*
INSTRUCTIONS FOR USE

This script is intended as a single-script drop in for separate leash points or
"virtual collars" that can be worn on top of your regular collar, attaching
to an actual collar via the add-ons system. It's two main uses are to provide an 
alternate leash point for a collar (for example, it could be added to a nose ring) or
to effectively replace the visual component of a collar (thus the collar scripts could
be worn in a HUD while various designs of collar could be used with different outfits, 
each with just this script in it, or an outfit-specific collar can be worn on top of a
regular hidden collar, so that you don't need to unlock, remove and replace a collar if 
you change avatar to one your regular collar doesn't fit. Clicking the object this script
is in will bring up the collar's menu, and the autohide command in the add-on menu, when
active, will cause your regular collar to autohide when the item containing this script is
worn.

The menu to control an attached device can be found in your collar's add-ons menu, where
you will find a button named for the attachment. The menu inside here contains three buttons:
LOCK - toggles locking the add-on object
AUTOHIDE - Toggles autohiding your actual collar when this is worn. If you're using this for 
"virtual collar" then switch this on. If you're using it as an alternative leash point, don't.
ACTIVATE - Toggles the item on/off.

INSTALLATION
This can be installed in any attachment with mod perms. If your attachment is rigged mesh, then
the source of particles drawn from it is unpredictable and might not be well positioned. In such
cases, first ensure that the item is actually attached to a logical attachment point, and if that
does not give a visually satisfying solution, link a small invisible prim to the attachment and edit
it into the correct position for the leash to connect to.

To install, simply drop the script into the attachment's contents. We strongly suggest having
a child prim as your leash point as described above, and that prim should be named
"leashpoint". While you can drop this script directly into a suitable child prim and not bother 
with this step, not all features will work so we don't recommend it. The attachment will appear
in your collar's add-on menu when connected, and will show up as a button named by the prim that 
the script is found in. If you have placed the script in a child prim but wish the button to show
the name of the object, edit the script to change the line:
string g_sAddon = "PRIMNAME";
...to instead read:
string g_sAddon = "OBJECTNAME";
You'll find this line around line 95ish of the script.

When installed, remove your attachment (or pick it up if rezzed) to ensure changes are saved, 
then reattach it.

If you are using this for an alternative leashpoint, that's all you need to do. As a virtual
collar, you'll want to activate Autohide in the menu (found in the collar's Add-Ons menu) so
that it'll automatically hide your actual collar when worn.

Designed by Nikki Lacrima, and based on:
-oc_addon_template RELEASED UNDER THE Public Domain-
Aria (tiff589) - (August 2020)
Lysea - (December 2020)
Taya'Phidoux' (taya.maruti) - (july 2021)
-oc_particle-
Copyright (c) 2008 - 2023 Lulu Pink, Nandana Singh, Garvin Twine,
Cleo Collins, Satomi Ahn, Joy Stipe, Wendy Starfall, Romka Swallowtail,
lillith xue, littlemousy, Nikki Lacrima et al.
Licensed under the GPLv2.  See LICENSE for full details. 
*/

/* 
oc_leashaddon
This file is part of OpenCollar.
Licensed under the GPLv2.  See LICENSE for full details. 

Nikki Lacrima
    Oct 2025  -   Leash Addon to replace collar leashpoint

Medea Destiny
    Oct 2025  -   Added autohide function to menu. When active, collar hides on connect
                and shows on disconnect if previously hiding. Also set script to reset
                on CHANGED_LINK and make touch trigger collar menu
                
*/

integer g_iAutohide=FALSE; // set to TRUE to make object autohide collar when worn.
integer g_iSentHide;
integer API_CHANNEL = 0x60b97b5e;
integer LM_CHANNEL = -8888;

string g_sAddon = "PRIMNAME"; //  "OBJECTNAME" : replaced by object name, "PRIMNAME" : replace by prim name
string g_sLeashgroup = "Addon Leash"; // String used to identify this script when sending CMD_PARTICLE unleash
integer g_iAddonActive = TRUE;
integer g_iAddonLocked = FALSE;

//integer CMD_ZERO            = 0;
integer CMD_OWNER           = 500;
//integer CMD_TRUSTED         = 501;
//integer CMD_GROUP           = 502;
integer CMD_WEARER          = 503;
integer CMD_EVERYONE        = 504;
//integer CMD_BLOCKED         = 598; // <--- Used in auth_request, will not return on a CMD_ZERO
//integer CMD_RLV_RELAY       = 507;
//integer CMD_SAFEWORD        = 510;
//integer CMD_RELAY_SAFEWORD  = 511;
//integer CMD_NOACCESS        = 599;

integer LM_SETTING_SAVE     = 2000; //scripts send messages on this channel to have settings saved, <string> must be in form of "token=value"
integer LM_SETTING_REQUEST  = 2001; //when startup, scripts send requests for settings on this channel
integer LM_SETTING_RESPONSE = 2002; //the settings script sends responses on this channel
integer LM_SETTING_DELETE   = 2003; //delete token from settings
//integer LM_SETTING_EMPTY    = 2004; //sent when a token has no value

integer DIALOG          = -9000;
integer DIALOG_RESPONSE = -9001;
integer DIALOG_TIMEOUT  = -9002;

/*********************** Leash particle handling and settings from oc_particle ****************************/
integer CMD_PARTICLE = 20000;

key g_kLeashedTo = NULL_KEY;
key g_kParticleTarget;
integer g_bLeasherIsAv = FALSE;

integer g_iLeashActive;
integer g_iTurnMode;
integer g_iStrictMode;
integer g_iStrictRank;
string g_sParticleMode = "Ribbon"; //modes can be: Ribbon, Classic and noParticle
string g_sRibbonTexture;
string g_sClassicTexture;
//List of 4 leash/chain points, lockmeister names used (list has to be all lower case, prims dont matter, converting on compare to lower case)
//strided list... LM name, linkNumber, BOOL_ACVTIVE
list g_lLeashPrims;

string UPMENU       = "BACK";
string PARENTMENU   = "Leash";
string SUBMENU      = "Configure";
string L_COLOR      = "color";
string L_GRAVITY    = "gravity";
string L_SIZE       = "size";
string L_FEEL       = "feel";
string L_GLOW       = "shine";
string L_STRICT     = "strict";
string L_TURN       = "turn";
string L_DEFAULTS   = "RESET";
string L_CLASSIC_TEX= "Chain"; //texture name when using the classic particle stream
string L_RIBBON_TEX = "Silk"; //texture name when using the ribbon_mask particle stream
// Defalut leash particle, can read from defaultsettings:
// leashParticle=Shine~1~ParticleMode~Ribbon~R_Texture~Silk~C_Texture~Chain~Color~<1,1,1>~Size~<0.07,0.07,1.0>~Gravity~-0.7~C_TextureID~keyID~R_TextureID~keyID
list g_lDefaultSettings = [L_GLOW,"1",L_TURN,"0",L_STRICT,"0","particlemode","Ribbon","rtexture","Silk","ctexture","Chain",L_COLOR,"<1.0,1.0,1.0>",L_SIZE,"<0.04,0.04,1.0>",L_GRAVITY,"-1.0"];

list g_lSettings=g_lDefaultSettings;

string g_sParticleTexture = "Silk";
string g_sParticleTextureID; //we need the UUID for llLinkParticleSystem
string g_sChainParticleTexture; //default chains for Lock Guard
string g_sLeashParticleTexture;
//string g_sOccParticleTexture = "4cde01ac-4279-2742-71e1-47ff81cc3529";
string g_sLeashParticleMode;
vector g_vLeashColor = <1.00000, 1.00000, 1.00000>;
vector g_vLeashSize = <0.04, 0.04, 1.0>;
integer g_iParticleGlow = TRUE;
float g_fParticleAge = 3.5;
vector g_vLeashGravity = <0.0,0.0,-1.0>;
integer g_iParticleCount = 1;
float g_fBurstRate = 0.0;

list g_lCollarPoints = [ // oc chain name, lockmeister name, lockguard name
    "fcollar"   , "collar"  , "collarfrontloop" , // Collar Front
    "lcollar"   , "lcollar" , "collarleftloop"  , // Collar Left
    "rcollar"   , "rcollar" , "collarrightloop" , // Collar Right
    "bcollar"   , "bcollar" , "collarbackloop"    // Collar Back
];

FindLinkedPrims() {
    g_lLeashPrims = [];
    integer linkcount = llGetNumberOfPrims();
    integer i;

    for (i=-1; i<=linkcount;++i) {
        string sPrimName = llToLower(llStringTrim(llList2String(llGetLinkPrimitiveParams(i,[PRIM_NAME]),0),STRING_TRIM));
        if (sPrimName == "leashpoint" || sPrimName == "ooc") {
            g_lLeashPrims += ["fcollar", i];
            sPrimName = "fcollar";
        }
        integer iIndex = llListFindList(g_lCollarPoints,[sPrimName]);
        if (iIndex > -1) {
            g_lLeashPrims += [llList2String(g_lCollarPoints,iIndex),i];
            g_lLeashPrims += [llList2String(g_lCollarPoints,iIndex+1),i];
            g_lLeashPrims += [llList2String(g_lCollarPoints,iIndex+2),i];
        }
    }

    if (llListFindList(g_lLeashPrims,["fcollar"]) < 0){
        g_lLeashPrims += ["fcollar",llGetLinkNumber( ), "collar",llGetLinkNumber( ), "collarfrontloop",llGetLinkNumber( )];
    }
    //llOwnerSay((string)g_lLeashPrims);
}


Particles(integer iLink, key kParticleTarget, vector vScale) {
    //when we have no target to send particles to, dont create any
    if(g_sLeashParticleMode == "noParticle") {
        StopParticles(FALSE);
        return;
    }
    if (kParticleTarget == NULL_KEY) return;

    integer iFlags = PSYS_PART_FOLLOW_VELOCITY_MASK | PSYS_PART_TARGET_POS_MASK | PSYS_PART_FOLLOW_SRC_MASK;

    if (g_sParticleMode == "Ribbon") iFlags = iFlags | PSYS_PART_RIBBON_MASK;
    if (g_iParticleGlow) iFlags = iFlags | PSYS_PART_EMISSIVE_MASK;

    list lTemp = [
        PSYS_PART_MAX_AGE,g_fParticleAge,
        PSYS_PART_FLAGS,iFlags,
        PSYS_PART_START_COLOR, g_vLeashColor,
        //PSYS_PART_END_COLOR, g_vLeashColor,
        PSYS_PART_START_SCALE,vScale,
        //PSYS_PART_END_SCALE,g_vLeashSize,
        PSYS_SRC_PATTERN, PSYS_SRC_PATTERN_DROP,
        PSYS_SRC_BURST_RATE,g_fBurstRate,
        PSYS_SRC_ACCEL, g_vLeashGravity,
        PSYS_SRC_BURST_PART_COUNT,g_iParticleCount,
        //PSYS_SRC_BURST_SPEED_MIN,fMinSpeed,
        //PSYS_SRC_BURST_SPEED_MAX,fMaxSpeed,
        PSYS_SRC_TARGET_KEY,kParticleTarget,
        PSYS_SRC_MAX_AGE, 0,
        PSYS_SRC_TEXTURE, g_sParticleTextureID
        ];
    llLinkParticleSystem(iLink, lTemp);
}

StartParticles(key kParticleTarget) {
    //Debug(llList2CSV(g_lLeashPrims));
    StopParticles(FALSE);
    //llOwnerSay("start particles called for new target: "+(string)llKey2Name(kParticleTarget)+(string)kParticleTarget);
    g_sParticleTextureID = g_sLeashParticleTexture;
    g_sParticleMode = g_sLeashParticleMode;

    integer iIndex = llListFindList(g_lLeashPrims,["collar"]);
    if (iIndex > -1) {
        Particles(llList2Integer(g_lLeashPrims,iIndex+1),kParticleTarget,g_vLeashSize);
        g_iLeashActive = TRUE;
    }
}

StopParticles(integer iEnd) {
    integer iIndex = llListFindList(g_lLeashPrims,["collar"]);
    if (iIndex > -1) {
        llLinkParticleSystem(llList2Integer(g_lLeashPrims,iIndex+1), []);
    }

    if (iEnd) {
        g_iLeashActive = FALSE;
        g_kLeashedTo = NULL_KEY;
        g_kParticleTarget = NULL_KEY;
    }
}

SaveSettings(string sToken, string sValue) {
    integer iIndex = llListFindList(g_lSettings, [sToken]);
    if (iIndex>=0) g_lSettings = llListReplaceList(g_lSettings, [sValue], iIndex +1, iIndex +1);
    else g_lSettings += [sToken, sValue];

    if (sToken == "rtexture") {
        if (llToLower(llGetSubString(sValue,0,6)) == "!ribbon") L_RIBBON_TEX = llGetSubString(sValue, 8, -1);
        else L_RIBBON_TEX = sValue;
    }
    else if (sToken == "ctexture") {
        if (llToLower(llGetSubString(sValue,0,7)) == "!classic") L_CLASSIC_TEX = llGetSubString(sValue, 9, -1);
        else L_CLASSIC_TEX = sValue;
    }
}

string GetDefaultSetting(string sToken) {
    integer index = llListFindList(g_lDefaultSettings, [sToken]);
    if (index != -1) return llList2String(g_lDefaultSettings, index + 1);
    else return "";
}

string GetSetting(string sToken) {
    integer index = llListFindList(g_lSettings, [sToken]);
    if (index != -1) return llList2String(g_lSettings, index + 1);
    else return GetDefaultSetting(sToken); // return from defaultsettings if not present
}

integer g_iLeashLength=2;

// get settings before StartParticles
GetSettings(integer iStartParticles) {
   // Debug("settings: "+llList2CSV(g_lSettings));
    g_sLeashParticleMode = GetSetting("particlemode");
    g_sParticleMode = g_sLeashParticleMode;
    g_sClassicTexture = GetSetting("ctexture");
    g_sRibbonTexture = GetSetting("rtexture");
    g_vLeashSize = (vector)GetSetting(L_SIZE);
    g_vLeashColor = (vector)GetSetting(L_COLOR);
    g_vLeashGravity.z = (float)GetSetting(L_GRAVITY);
    g_iParticleGlow = (integer)GetSetting(L_GLOW);
    if (g_sLeashParticleMode == "Classic") SetTexture(g_sClassicTexture, NULL_KEY);
    else if (g_sLeashParticleMode == "Ribbon") SetTexture(g_sRibbonTexture, NULL_KEY);
    if (iStartParticles &&  g_kLeashedTo != NULL_KEY && g_iAddonActive){
        llSleep(0.1);
//        llWhisper(0, "start particles from settings");
        StartParticles(g_kParticleTarget);
    }
}

// Added bSave as a boolean, to make this a more versatile wrapper
SetTexture(string sIn, key kIn) {
    g_sParticleTexture = sIn;
    g_sLeashParticleTexture=(string)NULL_KEY;
    if (sIn=="Silk") g_sLeashParticleTexture="cdb7025a-9283-17d9-8d20-cee010f36e90";
    else if (sIn=="Chain") g_sLeashParticleTexture="4cde01ac-4279-2742-71e1-47ff81cc3529";
    else if (sIn=="Leather") g_sLeashParticleTexture="8f4c3616-46a4-1ed6-37dc-9705b754b7f1";
    else if (sIn=="Rope") g_sLeashParticleTexture="9a342cda-d62a-ae1f-fc32-a77a24a85d73";
    else if (sIn=="totallytransparent") g_sLeashParticleTexture=TEXTURE_TRANSPARENT;
    else {
        if (llToLower(g_sParticleTexture) == "noleash") g_sLeashParticleMode = "noParticle";
        //Debug("particleTexture= " + sIn);
        g_sLeashParticleTexture = llGetInventoryKey(g_sParticleTexture);
        if(g_sLeashParticleTexture == NULL_KEY) g_sLeashParticleTexture=sIn; //for textures without full perm, we send the texture name. For this to work, texture must be in the emitter prim as well as in root, if different.
    }

    if(g_sLeashParticleTexture!=(string)NULL_KEY)return;

    if (g_sLeashParticleMode == "Ribbon") {
        if (llToLower(llGetSubString(sIn,0,6)) == "!ribbon") L_RIBBON_TEX = llGetSubString(sIn, 8, -1);
        else L_RIBBON_TEX = sIn;
        if (GetSetting("rtexture")) g_sLeashParticleTexture = GetSetting("rtexture");

    }
    else if (g_sLeashParticleMode == "Classic") {
        if (llToLower(llGetSubString(sIn,0,7)) == "!classic") L_CLASSIC_TEX =  llGetSubString(sIn, 9, -1);
        else L_CLASSIC_TEX = sIn;
        if (GetSetting("ctexture")) g_sLeashParticleTexture = GetSetting("ctexture");

    }
    //Debug("particleTextureID= " + (string)g_sLeashParticleTexture);
    //Debug("activeleashpoints= " + (string)g_iLeashActive);
    g_sParticleMode = g_sLeashParticleMode;
    if (g_iLeashActive) {
        if (g_sLeashParticleMode == "noParticle") StopParticles(FALSE);
        else {
           // llWhisper(0, "texture change: restart particles");
            StartParticles(g_kParticleTarget);
        }
    }

}

/*  LockMeister protocol helper */

LockMeister_Initiate() {
    llRegionSay(LM_CHANNEL, (string)g_kLeashedTo+"handle");
    llRegionSay(LM_CHANNEL, (string)g_kLeashedTo+"collar");
    llRegionSayTo(g_kLeashedTo,LM_CHANNEL,(string)g_kLeashedTo+"|LMV2|RequestPoint|collar");
    llRegionSayTo(g_kLeashedTo,LM_CHANNEL,(string)g_kLeashedTo+"|LMV2|RequestPoint|handle");
    g_kParticleTarget=g_kLeashedTo;
    g_kLeashToCollar=NULL_KEY;
    g_kLeashToHandle=NULL_KEY;
    llSetTimerEvent(10.0);
}

LockMeister_Handler(string msg, key id) {
//llOwnerSay((string)id+" "+msg+" "+(string)g_kLeashedTo);
    key kLMKey = (key)llGetSubString(msg,0,35);
    list lLMCmd = llParseString2List(msg,["|"],[]);
    string sCmd = llGetSubString(msg,36,-1);
    if (kLMKey == g_kLeashedTo) { // Response from g_kLeashedTo 
        if (llGetListLength(lLMCmd) == 1) {
            // LM V1 dont overwrite V2
            if (sCmd == "handle ok" && g_kLeashToHandle==NULL_KEY) {
                g_kLeashToHandle = id;
            }
            if (sCmd == "collar ok" && g_kLeashToHandle==NULL_KEY) {
                g_kLeashToCollar = id;
            }
            else if  (sCmd == "handle detached") {
                llSetTimerEvent(1); // Let timer handle the update
                g_kLeashToHandle = NULL_KEY;
            }                    
        }
        else if (llList2String(lLMCmd,2)=="ReplyPoint") { // V2 ReplyPoint
            //llOwnerSay(msg); 
            if (llList2String(lLMCmd,3) == "handle") {
                g_kLeashToHandle = llList2Key(lLMCmd,4);
            } else if (llList2String(lLMCmd,3) == "collar") {
                g_kLeashToCollar = llList2Key(lLMCmd,4);                    
            }
        } // end of V2
    } // end of response from g_kLeashedTo
    if (kLMKey == llGetOwner()) { // Request handling is empty for now
    } 
}

/*********************** Standard Addon Template functions ****************************/

/*
 * Since Release Candidate 1, Addons will not receive all link messages without prior opt-in.
 * To opt in, add the needed link messages to g_lOptedLM = [], they'll be transmitted on
 * the initial registration and can be updated at any time by sending a packet of type `update`
 * Following LMs require opt-in:
 * [ALIVE, READY, STARTUP, CMD_ZERO, MENUNAME_REQUEST, MENUNAME_RESPONSE, MENUNAME_REMOVE, SAY, NOTIFY, DIALOG, SENSORDIALOG]
 */
list g_lOptedLM     = [];

list g_lCheckboxes=["□","▣"];
string Checkbox(integer iValue, string sLabel) {
    return llList2String(g_lCheckboxes, (iValue>0))+" "+sLabel;
}

Dialog(key kID, string sPrompt, list lChoices, list lUtilityButtons, integer iPage, integer iAuth, string sName) {
    
    llRegionSayTo(g_kCollar, API_CHANNEL, llList2Json(JSON_OBJECT, [ "pkt_type", "from_addon", "addon_name", g_sAddon, "iNum", DIALOG, "sMsg", (string)kID + "|" + sPrompt + "|" + (string)iPage + "|" + llDumpList2String(lChoices, "`") + "|" + llDumpList2String(lUtilityButtons, "`") + "|" + (string)iAuth, "kID", sName+"~"+g_sAddon+llGetScriptName() ]));

}

Menu(key kID, integer iAuth) {
    string sPrompt = "\n"+g_sAddon+"\n\nMake addon leashpoint override collar leashpoint:";
    if(llGetLinkNumber()>1) sPrompt+="(Warning, this script is not in object root, and therefore Autohide will not work)";
    list lButtons  = [llList2String(g_lCheckboxes, (g_iAddonActive>0))+" "+"Active",
                      llList2String(g_lCheckboxes, (g_iAddonLocked>0))+" "+"Locked",
                      llList2String(g_lCheckboxes, g_iAutohide)+" Autohide"];
    
    //llSay(0, "opening menu");
    Dialog(kID, sPrompt, lButtons, ["DISCONNECT", UPMENU], 0, iAuth, "Menu~Main");
}

UserCommand(integer iNum, string sStr, key kID) {
    if (iNum<CMD_OWNER || iNum>CMD_WEARER) return;
    if (llSubStringIndex(llToLower(sStr), llToLower(g_sAddon)) && llToLower(sStr) != "menu " + llToLower(g_sAddon)) return;
    if (iNum == CMD_OWNER && llToLower(sStr) == "runaway") {
        return;
    }

    if (llToLower(sStr) == llToLower(g_sAddon) || llToLower(sStr) == "menu "+llToLower(g_sAddon))
    {
        Menu(kID, iNum);
    }
    else
    {
        //integer iWSuccess   = 0; 
        //string sChangetype  = llList2String(llParseString2List(sStr, [" "], []),0);
        //string sChangevalue = llList2String(llParseString2List(sStr, [" "], []),1);
        //string sText;
    }
}

Link(string packet, integer iNum, string sStr, key kID){
    list packet_data = [ "pkt_type", packet, "iNum", iNum, "addon_name", g_sAddon, "bridge", FALSE, "sMsg", sStr, "kID", kID ];

    if (packet == "online" || packet == "update") // only add optin if packet type is online or update
    {
        packet_data += [ "optin", llDumpList2String(g_lOptedLM, "~") ];
    }

    string pkt = llList2Json(JSON_OBJECT, packet_data);
    if (g_kCollar != "" && g_kCollar != NULL_KEY)
    {
        llRegionSayTo(g_kCollar, API_CHANNEL, pkt);
    }
    else
    {
        llRegionSay(API_CHANNEL, pkt);
    }
}

key g_kCollar=NULL_KEY;
key g_kLeashToCollar=NULL_KEY;
key g_kLeashToHandle=NULL_KEY;
integer g_iLMLastRecv;
integer g_iLMLastSent;

default
{
    state_entry()
    {
        if(llGetLinkNumber()>1) llOwnerSay("Warning, "+llGetScriptName()+" is not in object root. This means autohide won't work and leashes won't auto-redraw to the collar if this is detached.");
        if (g_sAddon == "OBJECTNAME") g_sAddon = llGetLinkName(LINK_ROOT);
        if (g_sAddon == "PRIMNAME") g_sAddon = llGetLinkName(LINK_THIS);
        API_CHANNEL = ((integer)("0x" + llGetSubString((string)llGetOwner(), 0, 8))) + 0xf6eb - 0xd2;
        llListen(API_CHANNEL, "", "", "");
        llListen(LM_CHANNEL, "", "", "");
        Link("online", 0, "", llGetOwner()); // This is the signal to initiate communication between the addon and the collar
        g_iLMLastRecv = llGetUnixTime(); // Need to initialize this here in order to prevent resetting before we can receive our first pong
        llSetTimerEvent(60);
        FindLinkedPrims();
        GetSettings(FALSE);
        g_sChainParticleTexture = "4cde01ac-4279-2742-71e1-47ff81cc3529"; // Chain texture for LockGuard
        StopParticles(TRUE);
        // Script should only reset if it looses contact with collar, g_iAddonLocked=FALSE and remove detach lock
        // If we add persistent state then lock should be reapplied when contact with collar is established
        llOwnerSay("@detach=y");
    }
    
    attach(key id)
    {
        // if attached make a connectin when detached disconnect.
        if(id)
        {
            if (g_sAddon == "OBJECTNAME") g_sAddon = llGetLinkName(LINK_ROOT);
            if (g_sAddon == "PRIMNAME") g_sAddon = llGetLinkName(LINK_THIS);
            g_kCollar = NULL_KEY;
            g_kLeashedTo = NULL_KEY;
            g_kParticleTarget = NULL_KEY;
            if (g_iAddonLocked) llOwnerSay("@detach=n");
            llSleep(5);
            Link("online", 0, "", llGetOwner());
            // do like state_entry to fix random resets on teleport or login.
            llSetTimerEvent(60);
            g_iLMLastRecv = llGetUnixTime();
        }
        else
        {
            StopParticles(FALSE);
            if (g_kLeashedTo) Link("from_addon", CMD_PARTICLE, "leash|"+(string)g_bLeasherIsAv, g_kLeashedTo);        
            if(g_iSentHide==TRUE && g_iAutohide==TRUE)  Link("from_addon",0,"show",llGetOwner());     
            Link("offline", 0, "", llGetOwnerKey(g_kCollar));
        }
    }

    changed(integer change)
    {
        if (change & ( CHANGED_OWNER | CHANGED_INVENTORY | CHANGED_LINK) ) 
        {
            llResetScript();
        }
    }

    
    timer()
    {
        if (llGetUnixTime() >= (g_iLMLastSent + 30))
        {
            g_iLMLastSent = llGetUnixTime();
            Link("ping", 0, "", g_kCollar);
        }

        if (llGetUnixTime() > (g_iLMLastRecv + (5 * 60)) && g_kCollar != NULL_KEY)
        {
            g_kCollar = NULL_KEY;
            llResetScript(); // perform our action on disconnect
        }
        
        if (g_kCollar == NULL_KEY) Link("online", 0, "", llGetOwner());
        
        // LM leash handles, look for chnaged handles in order
        if (g_kLeashedTo!=NULL_KEY && g_iAddonActive) {
            //llOwnerSay("Timer g_kLeashedTo:"+(string)g_kLeashedTo);
            llSetTimerEvent(60);
            key kNewTarget = g_kLeashedTo;
            if (g_kLeashToCollar) kNewTarget = g_kLeashToCollar;
            if (g_kLeashToHandle) kNewTarget = g_kLeashToHandle;
            if (kNewTarget != g_kParticleTarget) {
                g_kParticleTarget = kNewTarget;
                StartParticles(g_kParticleTarget);
                Link("from_addon", CMD_PARTICLE, "unleash", g_sLeashgroup);
                llSetTimerEvent(10);
            }
            
            g_kLeashToCollar=NULL_KEY;
            g_kLeashToHandle=NULL_KEY;
            llRegionSay(LM_CHANNEL, (string)g_kLeashedTo+"handle");
            llRegionSay(LM_CHANNEL, (string)g_kLeashedTo+"collar");
            llRegionSayTo(g_kLeashedTo,LM_CHANNEL,(string)g_kLeashedTo+"|LMV2|RequestPoint|collar");
            llRegionSayTo(g_kLeashedTo,LM_CHANNEL,(string)g_kLeashedTo+"|LMV2|RequestPoint|handle");
        }
    }
    
    listen(integer channel, string name, key id, string msg){
        if (channel == API_CHANNEL) {
            string sPacketType = llJsonGetValue(msg, ["pkt_type"]);
            if (sPacketType == "approved" && g_kCollar == NULL_KEY)
            {
            // This signal, indicates the collar has approved the addon and that communication requests will be responded to if the requests are valid collar LMs.
                g_kCollar = id;
                g_iLMLastRecv = llGetUnixTime(); // Initial message should also count as a pong for timing reasons
                Link("from_addon", LM_SETTING_REQUEST, "ALL", "");
                if(g_iAutohide) 
                {
                    if(llGetLinkNumber()<=1)
                    {
                        Link("from_addon",0,"hide",llGetOwner());
                        g_iSentHide=TRUE;
                    }
                }
            }
            else if (sPacketType == "dc" && g_kCollar == id)
            {
                llOwnerSay("dc from collar"); 
                g_kCollar = NULL_KEY;
                llResetScript(); // This addon is designed to always be connected because it is a test
            }
            else if (sPacketType == "pong" && g_kCollar == id)
            {
                g_iLMLastRecv = llGetUnixTime();
            }
            else if(sPacketType == "from_collar")
            {
            // process link message if in range of addon
                if (llVecDist(llGetPos(), llList2Vector(llGetObjectDetails(id, [OBJECT_POS]), 0)) <= 10.0)
                {
                    integer iNum = (integer) llJsonGetValue(msg, ["iNum"]);
                    string sMessage  = llJsonGetValue(msg, ["sMsg"]);
                    key kMessageID  = (key) llJsonGetValue(msg, ["kID"]);
                
                    if (iNum == CMD_PARTICLE) {
                    //llOwnerSay(msg);
                        if (sMessage == "unleash") {
                            // Dont respond to message from g_sLeashgroup
                            if (kMessageID != g_sLeashgroup) {
                                g_kLeashedTo = NULL_KEY;
                                if (g_iAddonActive) StopParticles(TRUE);
                                llSetTimerEvent(60);
                            }
                        } else if (g_sLeashParticleMode != "noParticle") {
                            g_kLeashedTo = kMessageID;
                            g_bLeasherIsAv = (integer)llList2String(llParseString2List(sMessage, ["|"], [""]), 1);
                            g_kParticleTarget = g_kLeashedTo;
                            if (g_iAddonActive) {
                                StartParticles(g_kParticleTarget);
                                if (g_bLeasherIsAv) LockMeister_Initiate();
                                Link("from_addon", CMD_PARTICLE, "unleash", g_sLeashgroup);
                                llSetTimerEvent(2);
                            }
                        }
                    }
                    else if (iNum == LM_SETTING_RESPONSE)
                    {
                        list lPar     = llParseString2List(sMessage, ["_","="], []);
                        string sToken = llList2String(lPar, 0);
                        string sVar   = llList2String(lPar, 1);
                        string sVal   = llList2String(lPar, 2);

                        if (sToken ==  "particle") {
                            // load current settings
                            //Debug("Setting Response. "+sToken+sValue);
                            SaveSettings(sVar, sVal);
                            GetSettings(TRUE); // All setting changes are through LM_SETTING_RESPONSE
                        } else if (sToken ==  "leash") {
                            if (sVar == "leashedto") {
                                list lValues = llParseString2List(sVal, [","], [""]);
                                //integer g_iFollowMode = llList2Integer(lValues,3);
                                if ( ! llList2Integer(lValues,3)) {
                                    g_kLeashedTo = llList2Key(lValues,0);
                                } else { 
                                    //llOwnerSay("follow mode, no leash target set");
                                    g_kLeashedTo = NULL_KEY; 
                                }
                                llSetTimerEvent(10);
                            }
                        }
                    }
                    else if (iNum == LM_SETTING_DELETE)
                    {
                        if (sMessage == "leash_leashedto") g_kLeashedTo = NULL_KEY;
                    }
                    else if (iNum >= CMD_OWNER && iNum <= CMD_EVERYONE)
                    {
                        UserCommand(iNum, sMessage, kMessageID);         
                    }
                    else if (iNum == DIALOG_RESPONSE)
                    {
                        integer iPos = llSubStringIndex(kMessageID, "~"+g_sAddon+llGetScriptName());
                        if(iPos>0)
                        {
                            string sMenu = llGetSubString(kMessageID, 0, iPos-1);
                            list lMenuParams = llParseString2List(sMessage, ["|"], []);
                            key kAv = llList2Key(lMenuParams, 0);
                            string sMsg = llList2String(lMenuParams, 1);
                            integer iAuth = llList2Integer(lMenuParams, 3);
                        
                            if (sMenu == "Menu~Main")
                            {
                                if (sMsg == UPMENU)
                                {
                                    Link("from_addon", iAuth, "menu Addons", kAv);
                                    return;
                                }
                                else if (sMsg == llList2String(g_lCheckboxes, (g_iAddonActive>0))+" "+"Active")
                                {
                                    g_iAddonActive = !g_iAddonActive;
                                    if (g_iAddonActive)
                                    {
                                        if (g_kParticleTarget) {
                                            StartParticles(g_kParticleTarget);
                                            Link("from_addon", CMD_PARTICLE, "unleash", g_sLeashgroup);
                                        }
                                    }
                                    else
                                    {
                                        //llSay(0, "This is an example addon. Turn leash function off: "+(string)g_kLeashedTo);
                                        g_iAddonActive = FALSE;
                                        StopParticles(FALSE);
                                        if (g_kLeashedTo) Link("from_addon", CMD_PARTICLE, "leash|"+(string)g_bLeasherIsAv, g_kLeashedTo);
                                    }
                                }
                                else if (sMsg == llList2String(g_lCheckboxes, (g_iAddonLocked>0))+" "+"Locked")
                                {
                                    g_iAddonLocked = !g_iAddonLocked;
                                    if (g_iAddonLocked)
                                    {
                                        llOwnerSay("@detach=n");
                                    }
                                    else
                                    {
                                        llOwnerSay("@detach=y");
                                    }
                                } 
                                else if (llGetSubString(sMsg,2,-1)=="Autohide")
                                {
                                    g_iAutohide=!g_iAutohide;
                                    if (g_iAutohide)
                                    {
                                        Link("from_addon",0,"hide",llGetOwner());
                                        g_iSentHide=TRUE;
                                    }
                                    else  if(g_iSentHide)
                                    {
                                         Link("from_addon",0,"show",llGetOwner());
                                         g_iSentHide=FALSE;
                                    }

                                }                 
                                else if (sMsg == "DISCONNECT")
                                {
                                    Link("offline", 0, "", llGetOwnerKey(g_kCollar));
                                    g_kCollar = NULL_KEY;
                                }
                                Menu(kAv, iAuth);
                            }
                        }
                        
                    }
                }
            }
        } // end of API_CHANNEL
        else if (channel == LM_CHANNEL) {
            LockMeister_Handler(msg, id); 
        } // end of LM_CHANNEL
    }
    
    touch_start(integer iNum){
        Link("from_addon", 0, "menu",  llDetectedKey(0));
    }

}

